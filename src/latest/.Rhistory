prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
if(counter!=20) {b[i] = newp}
}
beta = post_beta(sigmaS.b, b)
sigmaS.b = post_sigmaS.b(b, beta)
mu = c(beta %*% t(W))
for(i in 1:N){
prob = 0
counter = 0
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
if(counter!=20) {b[i] = newp}
}
beta = post_beta(sigmaS.b, b)
sigmaS.b = post_sigmaS.b(b, beta)
mu = c(beta %*% t(W))
for(i in 1:N){
prob = 0
counter = 0
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
if(counter!=20) {b[i] = newp}
}
beta = post_beta(sigmaS.b, b)
sigmaS.b = post_sigmaS.b(b, beta)
mu = c(beta %*% t(W))
for(i in 1:N){
prob = 0
counter = 0
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
if(counter!=20) {b[i] = newp}
}
beta = post_beta(sigmaS.b, b)
sigmaS.b = post_sigmaS.b(b, beta)
mu = c(beta %*% t(W))
for(i in 1:N){
prob = 0
counter = 0
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
if(counter!=20) {b[i] = newp}
}
beta = post_beta(sigmaS.b, b)
sigmaS.b = post_sigmaS.b(b, beta)
mu = c(beta %*% t(W))
for(i in 1:N){
prob = 0
counter = 0
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
if(counter!=20) {b[i] = newp}
}
beta = post_beta(sigmaS.b, b)
sigmaS.b = post_sigmaS.b(b, beta)
mu = c(beta %*% t(W))
for(i in 1:N){
prob = 0
counter = 0
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
if(counter!=20) {b[i] = newp}
}
beta = post_beta(sigmaS.b, b)
sigmaS.b = post_sigmaS.b(b, beta)
mu = c(beta %*% t(W))
for(i in 1:N){
prob = 0
counter = 0
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
if(counter!=20) {b[i] = newp}
}
for(t in 1:n){
# Here for each time step, we sample each parameter once,
# Note that a.t and b.j.x are sampled using MH
#--------1
beta = post_beta(sigmaS.b, b)
sigmaS.b = post_sigmaS.b(b, beta)
mu = c(beta %*% t(W))
for(i in 1:N){
prob = 0
counter = 0
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
if(counter!=20) {b[i] = newp}
}
#----------------------2
# alpha = post_alpha(sigmaS.delta, alpha.X)
# sigmaS.delta= post_sigmaS.delta(alpha, alpha.X)
# prob = 0
# while(runif(1) > prob){
#   newa = trans_a.t(a.t)
#   prob = post_a.t(newa, b.t, tauS.X) / post_a.t(a.t,b.t,tauS.X)
# }
# a.t = newa
# b.t = post_b.t(a.t,tauS.X)
# alpha.X = post_alpha.x(tauS.X, sigmaS.delta)
#
# tauS.X = post_tauS.x(a.t, b.t, alpha.X)
#----------------1
#we append the new samples to the arrays.
#sam_betas[t,] = beta
#sam_sigmaS.b[t] = sigmaS.b
#sam_b[t,] = b
#-------------------------2
# sam_alpha[t] = alpha
# sam_sigmaS.delta[t] = sigmaS.delta
# sam_a.t[t] = a.t
# sam_b.t[t] = b.t
# sam_alpha[t,] = alpha.X
# sam_tauS[t,] = tauS.X
}
t
post_beta(sigmaS.b, b)
post_sigmaS.b(b, beta)
beta
sigmaS.b
post_sigmaS.b(b, beta)
c(beta %*% t(W))
i
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
for(t in 1:n){
# Here for each time step, we sample each parameter once,
# Note that a.t and b.j.x are sampled using MH
#--------1
beta = post_beta(sigmaS.b, b)
sigmaS.b = post_sigmaS.b(b, beta)
mu = c(beta %*% t(W))
for(i in 1:N){
prob = 0
counter = 0
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
if(counter!=20) {b[i] = newp}
}
#----------------------2
# alpha = post_alpha(sigmaS.delta, alpha.X)
# sigmaS.delta= post_sigmaS.delta(alpha, alpha.X)
# prob = 0
# while(runif(1) > prob){
#   newa = trans_a.t(a.t)
#   prob = post_a.t(newa, b.t, tauS.X) / post_a.t(a.t,b.t,tauS.X)
# }
# a.t = newa
# b.t = post_b.t(a.t,tauS.X)
# alpha.X = post_alpha.x(tauS.X, sigmaS.delta)
#
# tauS.X = post_tauS.x(a.t, b.t, alpha.X)
#----------------1
#we append the new samples to the arrays.
#sam_betas[t,] = beta
#sam_sigmaS.b[t] = sigmaS.b
#sam_b[t,] = b
#-------------------------2
# sam_alpha[t] = alpha
# sam_sigmaS.delta[t] = sigmaS.delta
# sam_a.t[t] = a.t
# sam_b.t[t] = b.t
# sam_alpha[t,] = alpha.X
# sam_tauS[t,] = tauS.X
}
}
for(t in 1:n){
# Here for each time step, we sample each parameter once,
# Note that a.t and b.j.x are sampled using MH
#--------1
beta = post_beta(sigmaS.b, b)
sigmaS.b = post_sigmaS.b(b, beta)
mu = c(beta %*% t(W))
for(i in 1:N){
prob = 0
counter = 0
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
if(counter!=20) {b[i] = newp}
}
}
for(t in 1:n){
# Here for each time step, we sample each parameter once,
# Note that a.t and b.j.x are sampled using MH
#--------1
beta = post_beta(sigmaS.b, b)
sigmaS.b = post_sigmaS.b(b, beta)
mu = c(beta %*% t(W))}
for(t in 1:n){
# Here for each time step, we sample each parameter once,
# Note that a.t and b.j.x are sampled using MH
#--------1
beta = post_beta(sigmaS.b, b)
sigmaS.b = post_sigmaS.b(b, beta)
mu = c(beta %*% t(W))}
for(t in 1:n){
# Here for each time step, we sample each parameter once,
# Note that a.t and b.j.x are sampled using MH
#--------1
beta = post_beta(sigmaS.b, b)
sigmaS.b = post_sigmaS.b(b, beta)
mu = c(beta %*% t(W))}
for(t in 1:n){
# Here for each time step, we sample each parameter once,
# Note that a.t and b.j.x are sampled using MH
#--------1
beta = post_beta(sigmaS.b, b)
sigmaS.b = post_sigmaS.b(b, beta)
mu = c(beta %*% t(W))}
for(t in 1:n){
# Here for each time step, we sample each parameter once,
# Note that a.t and b.j.x are sampled using MH
#--------1
beta = post_beta(sigmaS.b, b)
sigmaS.b = post_sigmaS.b(b, beta)
mu = c(beta %*% t(W))}
for(t in 1:n){
# Here for each time step, we sample each parameter once,
# Note that a.t and b.j.x are sampled using MH
#--------1
beta = post_beta(sigmaS.b, b)
sigmaS.b = post_sigmaS.b(b, beta)
mu = c(beta %*% t(W))}
for(t in 1:n){
# Here for each time step, we sample each parameter once,
# Note that a.t and b.j.x are sampled using MH
#--------1
beta = post_beta(sigmaS.b, b)
sigmaS.b = post_sigmaS.b(b, beta)
mu = c(beta %*% t(W))}
for(t in 1:n){
# Here for each time step, we sample each parameter once,
# Note that a.t and b.j.x are sampled using MH
#--------1
beta = post_beta(sigmaS.b, b)
sigmaS.b = post_sigmaS.b(b, beta)
mu = c(beta %*% t(W))}
for(t in 1:n){
# Here for each time step, we sample each parameter once,
# Note that a.t and b.j.x are sampled using MH
#--------1
# beta = post_beta(sigmaS.b, b)
# sigmaS.b = post_sigmaS.b(b, beta)
# mu = c(beta %*% t(W))
for(i in 1:N){
prob = 0
counter = 0
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
if(counter!=20) {b[i] = newp}
}
}
for(t in 1:n){
# Here for each time step, we sample each parameter once,
# Note that a.t and b.j.x are sampled using MH
#--------1
# beta = post_beta(sigmaS.b, b)
# sigmaS.b = post_sigmaS.b(b, beta)
# mu = c(beta %*% t(W))
for(i in 1:N){
prob = 0
counter = 0
while(runif(1) > prob & counter < 20){
# newp ~ Q(p|p')
counter = counter + 1
newp = trans_b.j.x(mu[i], sigmaS.b)
#newp = propos_b.j.x(betas, f[i], d[i], sigmaS.b)
# probability of acceptance = p(p)/p(p')
prob = post_b.j.x(newp,mu[i],M[i],f[i], sigmaS.b) /
post_b.j.x(b[i],mu[i],M[i],f[i], sigmaS.b)
}
if(counter!=20) {b[i] = newp}
}
}
n
